#!/bin/bash -e

# This is a helper function to output floating point/decimal division
# It takes two integers as arguments and divides them to return the decimal value
# Full credit to user bebbo in:
# https://stackoverflow.com/questions/12722095/how-do-i-use-floating-point-division-in-bash
div() {
  local _d=${3:-2}
  local _n=00000000
  _n=${_n:0:$_d}
  local _r=$(($1$_n/$2))
  _r=${_r:0:-$_d}.${_r: -$_d}
  echo $_r
}

############################################################################
# Function dims takes a file with a numbers matrix as an argument and prints
# the dimensions of the matrix as the number of rows, followed by a space,
# then the number of columns. Do not use any other languages other than bash 
# shell scripting: this means that, among others, awk, sed, tcl, bc, perl, 
# & the python languages and tools are off-limits. Use of array is discouraged.
############################################################################
dims(){
	#If number of arguments != 1
	if [ "$#" -gt 1 ]; then
		echo "Invalid arguments." 1>&2
		exit 1
	fi

	if [ "$#" -eq 1 ] && ! [ -f $1 ]; then
		echo "Invalid files." 1>&2
		exit 1
	fi

	# Read from supplied file or from stdin 
    [ $# -ge 1 -a -f "$1" ] && input="$1" || input="/dev/stdin"
    touch outp
    printf "" > outp

	# Read the input into a temp file
    while read line; do
		for i in $line; do
			printf "%s\t" $i >> outp
			c_cnt=$(($c_cnt + 1))
		done
        printf "\n" >> outp
    done < "${1:-/dev/stdin}"

	#Get nummer of lines and display without the iflle's name
	lineCnt=$( wc --lines outp | cut -d' ' --fields=1 )

	#Get the first line and count the number of words
	colCnt=$( head --lines=1 outp | wc -w )

	#output results
	echo -e "$lineCnt\t$colCnt" > outp; cat outp #; rm -f outp
}

############################################################################
# Function transpose takes a file with a numbers matrix as an argument and
# reflects the elements of the matrix along the main diagonal.
# Do not use any other languages other than bash shell scripting: this means that,
# among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Thus, an MxN matrix becomes an NxM matrix and 
# the values along the main diagonal remain unchanged. Use of array is discouraged.
############################################################################
transpose(){
	trap "rm -f tr_temp_*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM
	
	#If number of arguments != 1
	if [ "$#" -gt 1 ]; then
		echo "Invalid arguments." 1>&2
		exit 1
	fi

	if [ "$#" -eq 1 ] && ! [ -f $1 ]; then
		echo "Invalid files." 1>&2
		exit 1
	fi

	# Read from supplied file or from stdin 
    [ $# -ge 1 -a -f "$1" ] && input="$1" || input="/dev/stdin"
	
	touch outp_tr$$
    printf "" > outp_tr$$

	# Read the input into a temp file
    while read line; do
		c_cnt=1
		for i in $line; do
			printf "%s\t" $i >> outp_tr$$
			c_cnt=$(($c_cnt + 1))
		done
	        printf "\n" >> outp_tr$$
    done < "${1:-/dev/stdin}"

	#Get nummer of lines and columns in argument file
	lineCnt=$( wc --lines outp_tr$$ | cut -d' ' --fields=1 )
	colCnt=$( head --lines=1 outp_tr$$ | wc -w )

	# Create one file for each column
	x=$colCnt
	while [ $x -gt 0 ]; do
		# Create new temp file or clear previously created files
		touch tr_temp_$x
		printf "" > tr_temp_$x
		x=$(($x-1))
	done

	# Store numbers in temp file in single row
	# Each column in argument file is transposed
	# into a row in temp file
	while read line; do
		#track column count
		c_cnt=1
		for i in $line; do
			# Write the number into a file
			printf "%s\t" $i >> tr_temp_$c_cnt
			c_cnt=`expr $c_cnt + 1 `
		done
	done < outp_tr$$ # Read file supplied in argument 1

	# cat out temp files in ascending order
	cntr=1
	
	printf "" > outp_tr$$
	while [ $cntr -le $colCnt ]; do
		cat tr_temp_$cntr >> outp_tr$$
		truncate -s-1 outp_tr$$
		printf "\n" >> outp_tr$$
		let cntr=cntr+1
	done
	cat -e -A outp_tr$$
	#cat outp_tr$$
	#remov temp files
	find . -maxdepth 1 -name "tr_temp_*" -exec rm -f {} \;
}

############################################################################
# mean should take an MxN matrix and return an 1xN row vector, where the first
# element is the mean of column one, the second element is the mean of column two,
# and so on. Do not use any other languages other than bash shell scripting:
# this means that, among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Use of array is discouraged.
############################################################################
mean () {
	trap "rm -f mean_temp.*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM
	if [ "$#" != 1 ] #If number of arguments != 1
	then
		echo "Invalid number of supplied arguments" 1>&2
		exit 1
	fi

	#Get nummer of lines and columns in argument file
	lineCnt=$( wc --lines $1 | cut -d' ' --fields=1 )
	colCnt=$( head --lines=1 $1 | wc -w )
	pid=$$

	# Create one file for each column
	x=$colCnt
	while [ $x -gt 0 ];
	do
		# Create new temp file or clear previously created files
		touch mean_temp.$x
		printf "" > mean_temp.$x
		x=$(($x-1))
	done

	# Store numbers in temp file in single row
	# Each column in argument file is transposed
	# into a row in temp file
	while read line
	do
		#track column count
		c_cnt=1
		for i in $line
		do
			# Write the number into a file
			printf "$i " >> mean_temp.$c_cnt
			c_cnt=$(expr $c_cnt + 1 )
		done
	done < $1 # Read file supplied in argument 1

	# Calculate the mean and store it in a temp file
	cnt=1
	touch mean_temp.o # Create temp file
	while [ $cnt -le $colCnt ]
	do
		printf "\n" >> mean_temp.$cnt
		while read line
		do
			# Sum the numbers
			sum=0
			for i in $line
			do
				sum=$( expr $sum + $i )
			done
		done < mean_temp.$cnt
		# Calculate mean and output to temp file
		printf "$( div $sum $lineCnt ) " >> mean_temp.o
		cnt=$(expr $cnt + 1 )
	done

	#Output results and remove temp files
	cat mean_temp.o
	find . -maxdepth 1 -name 'mean_temp*' -exec rm -f {} \;
}

###################################################################################
# add should take two MxN matrices and add them together element-wise to produce an MxN matrix.
# add should return an error if the matrices do not have the same dimensions.
# Do not use any other languages other than bash shell scripting:
# this means that, among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Use of array is discouraged.
####################################################################################
add(){
	trap "rm -f add_temp.*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM
	if [ "$#" != 2 ]
	then
		#Number of supplied arguments is not 2
		echo "Invalid number of supplied arguments" 1>&2
		exit 1
	fi

	find . -maxdepth 1 -name 'add_temp.*' -exec rm -f {} \;

	#Get nummer of lines
	lineCnt1=$( wc --lines $1 | cut -d' ' --fields=1 )
	lineCnt2=$( wc --lines $2 | cut -d' ' --fields=1 )

	#Get the first line and count the number of words
	colCnt1=$( head --lines=1 $1 | wc -w )
	colCnt2=$( head --lines=1 $2 | wc -w )
	coldbl=$(($colCnt1 * 2))

	if [ $lineCnt1 -ne $lineCnt2 ] || [ $colCnt1 -ne $colCnt2 ]
	then
		# Supplied matrices are not equal
		echo "Supplied matrices are not equal" 1>&2
		exit 1
	fi

	# Store numbers in seperate temp files
	# track file count
	f_cnt=1
	while read line
	do
		for i in $line
		do
			# Write the number into a file
			printf "$i " >> add_temp.$f_cnt
			f_cnt=$(expr $f_cnt + 1 )
		done
	done < $1 # Read file supplied in argument 1

	while read line
	do
		for i in $line
		do
			# Write the number into a file
			printf "$i " >> add_temp.$f_cnt
			f_cnt=$(expr $f_cnt + 1 )
		done
	done < $2 # Read file supplied in argument 2

	# Calculate the sums and store in a temp file
	# Create temp file for storing calculated matrix
	cnt=1
	matrix_cnt=$(( $f_cnt / 2 ))
	touch add_temp.o
	printf "" > add_temp.o
	while [ $cnt -le $matrix_cnt ]
	do
		#printf "last!\n"
		cnt2=$( expr $cnt + $matrix_cnt )

		# Sum the numbers. Take number from current file
		# and add it with the number from (current file + numer of entries in matrix)
		sum=0
		num1=$( head -c1 add_temp.$cnt )
		sum=$( expr $sum + $num1 )

		num2=$( head -c1 add_temp.$cnt2 )
		sum=$( expr $sum + $num2 )

		# Form summed matrix
		if (( $cnt % $colCnt1 != 0 ))
		then
			# delimitate with tab
			printf "$sum\t" >> add_temp.o
		else
			# delimitate with new line
			printf "$sum\n" >> add_temp.o
		fi
		cnt=$(expr $cnt + 1 )
	done

	# Output results and remove temp files
	cat add_temp.o
	find . -maxdepth 1 -name 'add_temp*' -exec rm -f {} \;
}

########################################################################################
# multiply should take an MxN and NxP matrix and produce an MxP matrix.
# Note that, unlike addition, matrix multiplication is not commutative. That is A*B != B*A.
# Do not use any other languages other than bash shell scripting:
# this means that, among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Use of array is discouraged.
########################################################################################
multiply(){
	trap "rm -f p_tmp.*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM
	if [ "$#" != 2 ]
	then
		#Number of supplied arguments is not 2
		echo "Invalid number of supplied arguments" 1>&2
		exit 1
	fi

	#Get nummer of rows and columns in each matrix
	lineCnt1=$( wc --lines $1 | cut -d' ' --fields=1 )
	lineCnt2=$( wc --lines $2 | cut -d' ' --fields=1 )
	colCnt1=$( head --lines=1 $1 | wc -w )
	colCnt2=$( head --lines=1 $2 | wc -w )

	if [ $colCnt1 != $lineCnt2 ]
	then
		#Number of supplied arguments is not 2
		echo "Mtrices cannot be multiplied" 1>&2
		exit 1
	fi

	# Store numbers in seperate temp files. Track file count
	l=1
	while read line
	do
		f=1
		for i in $line
		do
			# Write the number into a file. Name the file with col and row index
			printf "" > p_tmp.1.$l.$f
			printf "$i\n" >> p_tmp.1.$l.$f
			f=$(expr $f + 1)
		done
		l=$(expr $l + 1)
	done < $1 # Read file supplied in argument 1

	l=1
	while read line
	do
		f=1
		for i in $line
		do
			# Write the number into a file. Name the file with col and row index
			printf "" > p_tmp.2.$l.$f
			printf "$i " >> p_tmp.2.$l.$f
			f=$(expr $f + 1)
		done
		l=$(expr $l + 1)
	done < $2 # Read file supplied in argument 2

	printf "" > p_tmp.o # output file
	cntr=1
	m1rows=1
	while [ $m1rows -le $lineCnt1 ] # Iterate each row in m1
	do
		m2cols=1
		while [ $m2cols -le $colCnt2 ] # Iterate each column in m2
		do
			m2rows=1
			sum=0
			
			while [ $m2rows -le $lineCnt2 ] # Iterate each row in m2
			do
				# Multiply m1 file and m2 file then add result to running sum
				n1=$( head -c1 p_tmp.1.$m2cols.$m2rows )
				n2=$( head -c1 p_tmp.2.$m2rows.$m1rows )
				sum=$(($sum + $n1 * $n2))
				
				m2rows=$(($m2rows + 1))
			done
			#printf "$sum\t" >> p.tmp_o # Write each product sum
			
			if [ $cntr == $colCnt2 ]
			then
				printf "$sum\n" >> p_tmp.o # Write each product sum
				cntr=1
			else
				printf "$sum\t" >> p_tmp.o # Write each product sum
				cntr=$(($cntr+1))
			fi

			m2cols=$(($m2cols + 1))
		done
		m1rows=$(($m1rows + 1))
	done
	transpose p_tmp.o

	# Output results and remove temp files
	find . -maxdepth 1 -name 'p_tmp.*' -exec rm -f {} \;
}


function generate(){
	y=0
	a=$3
	b=$4
	while [ "$y" -lt "$1" ]
	do
		x=0
		((y++))
		while [ "$x" -lt "$2" ]
		do
			((x++))
			echo -n $((RANDOM%(b-a+1)+a))
			if [ "$x" -ne "$2" ]
			then
			echo -ne "\t"
			else
				echo
			fi
		done
	done
}

generate 5 6 -10 10 > f_tst

#$1 "${@:2}"
#echo -e "\n$1 exit with $?"


