#!/bin/bash -e

############################################################################################
# This is a helper function to output floating point/decimal division
# It takes two integers as arguments and divides them to return the decimal value
# Full credit to user bebbo in:
# https://stackoverflow.com/questions/12722095/how-do-i-use-floating-point-division-in-bash
############################################################################################
div() {
  local _d=${3:-2}
  local _n=00000000
  _n=${_n:0:$_d}
  local _r=$(($1$_n/$2))
  _r=${_r:0:-$_d}.${_r: -$_d}
  echo $_r
}

############################################################################
# Function dims takes a file with a numbers matrix as an argument and prints
# the dimensions of the matrix as the number of rows, followed by a space,
# then the number of columns. Do not use any other languages other than bash 
# shell scripting: this means that, among others, awk, sed, tcl, bc, perl, 
# & the python languages and tools are off-limits. Use of array is discouraged.
############################################################################
dims()
{
  lineCnt=0
  while read myLine; do
    lineCnt=$(($lineCnt + 1))
  done < $1

	#Get the first line and count the number of words
	colCnt=$( head --lines=1 $1 | wc -w )
  echo -e "$lineCnt $colCnt"
}

############################################################################
# Function transpose takes a file with a numbers matrix as an argument and
# reflects the elements of the matrix along the main diagonal.
# Do not use any other languages other than bash shell scripting: this means that,
# among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Thus, an MxN matrix becomes an NxM matrix and 
# the values along the main diagonal remain unchanged. Use of array is discouraged.
############################################################################
transpose(){
	trap "rm -f tr_temp_*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM
	
	touch outp_tr$$
  printf "" > outp_tr$$

	# Read the input into a temp file
    while read line; do
		c_cnt=1
		for i in $line; do
			printf "%s\t" $i >> outp_tr$$
			c_cnt=$(($c_cnt + 1))
		done
	        printf "\n" >> outp_tr$$
    done < $1

	#Get nummer of lines and columns in argument file
	lineCnt=$( wc --lines outp_tr$$ | cut -d' ' --fields=1 )
	colCnt=$( head --lines=1 outp_tr$$ | wc -w )

	# Create one file for each column
	x=$colCnt
	while [ $x -gt 0 ]; do
		# Create new temp file or clear previously created files
		touch tr_temp_$x
		printf "" > tr_temp_$x
		x=$(($x-1))
	done

	# Store numbers in temp file in single row
	# Each column in argument file is transposed
	# into a row in temp file
	while read line; do
		#track column count
		c_cnt=1
		for i in $line; do
			# Write the number into a file
			printf "%s\t" $i >> tr_temp_$c_cnt
			c_cnt=`expr $c_cnt + 1 `
		done
	done < outp_tr$$ # Read file supplied in argument 1

	# cat out temp files in ascending order
	cntr=1
	printf "" > outp_tr$$
	while [ $cntr -le $colCnt ]; do
		cat tr_temp_$cntr >> outp_tr$$
		truncate -s-1 outp_tr$$
		printf "\n" >> outp_tr$$
		let cntr=cntr+1
	done
	#cat -e -A outp_tr$$
	cat outp_tr$$
	#remov temp files
	find . -maxdepth 1 -name "tr_temp_*" -exec rm -f {} \;
}

############################################################################
# mean should take an MxN matrix and return an 1xN row vector, where the first
# element is the mean of column one, the second element is the mean of column two,
# and so on. Do not use any other languages other than bash shell scripting:
# this means that, among others, awk, sed, tcl, bc, perl, & the python languages
# and tools are off-limits. Use of array is discouraged.
############################################################################
mean () {
	#trap "rm -f mean_temp.*; echo 'CTRL+C received, exiting'; exit 1; " INT HUP TERM

	#Get nummer of lines and columns in argument file
  lineCnt=0
  while read myLine; do
    lineCnt=$(($lineCnt + 1))
  done < $1
	colCnt=$( head --lines=1 $1 | wc -w )

	# Create one file for each column
	x=$colCnt
	while [ $x -gt 0 ];
	do
		# Create new temp file or clear previously created files
		touch mean_temp.$x
		printf "" > mean_temp.$x
		x=$(($x-1))
	done

	# Store numbers in temp file in single row
	# Each column in argument file is transposed
	# into a row in temp file
	while read line
	do
		#track column count
		c_cnt=1
		for i in $line
		do
			# Write the number into a file
      if [ "$c_cnt" -eq "$lineCnt" ]; then
			  printf "%s\n" $i >> mean_temp.$c_cnt
      else
        printf "%s\t" $i >> mean_temp.$c_cnt
      fi
			c_cnt=$(expr $c_cnt + 1 )
		done
	done < $1 # Read file supplied in argument 1

	# Calculate the mean and store it in a temp file
	cnt=1
	touch mean_temp$$ # Create temp file
	while [ $cnt -le $colCnt ]
	do
		printf "\n" >> mean_temp.$cnt
		while read line
		do
			# Sum the numbers
			sum=0
			for i in $line
			do
				sum=$( expr $sum + $i )
			done
		done < mean_temp.$cnt
		
    # Calculate mean and output to temp file
		printf "$( div $sum $lineCnt )\t" >> mean_temp$$
		cnt=$(expr $cnt + 1 )
	done
  truncate -s-1 mean_temp$$
  printf "\n" >> mean_temp$$
	#Output results and remove temp files
	cat -A mean_temp$$
	#find . -maxdepth 1 -name 'mean_temp*' -exec rm -f {} \;
}


add()
{
 echo "Add function"
}


mulitply()
{
  echo "Multiply Function"
}

#mean m_5

if [[ $# > 3 ]]; then echo "Too many arguments passed" 1>&2; exit 1; fi
# Condition prechecks for dims and mean functions
if [ $1 = "mean" ] || [ $1 = "dims" ] ; then
  if [ ! -f $2 ] ; then echo "Invalid file" 1>&2; exit 1; fi
  if [[ $# > 2 ]] ; then echo "Too many arguments passed" 1>&2; exit 1; fi
  if [[ $# > 1 ]] ; then fileOne=$2; fileTwo=$3; fi
  if [[ $# == 1 ]] ; then fileOne=tmp; cat > $fileOne; fi
  if [ $1 = "dims" ]; then dims $fileOne; fi
  if [ $1 = "mean" ]; then mean $fileOne; fi
fi

# Condition prechecks for transpose
if [ $1 = "transpose" ]; then
  if [[ $# > 2 ]]; then echo "Invalid number of arguments" 1>&2; exit 1;
  elif [ $# -gt 1 ]; then fileOne=$2; fileTwo=$3
  elif [ $# -eq 1 ]; then fileOne=tmp; cat > $fileOne
  fi
  if [ ! -r $2 ]; then echo "Invalid file" 1>&2; exit 1; fi
  transpose $fileOne
fi

# Condition prechecks for add
if [ $1 = "add" ]; then 
  if [ $# -eq 0 ]; then echo "No arguments to add" 1>&2; exit 1; fi
  if [ $# -ne 2 ]; then echo "Invalid number of arguments" 1>&2; exit 1; fi
  if [ ! -r $2 ] || [ ! -r $3 ]; then echo "Invalid file" 1>&2; exit 1; fi
  add $fileOne $fileTwo
fi